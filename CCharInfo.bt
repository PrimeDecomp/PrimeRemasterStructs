#ifndef _CCHARINFO
#define _CCHARINFO

local int charinfoi <hidden=true> = 0;

struct SNodeSet {
    ushort nodeCount;
    ushort unk1;
    if (nodeCount) {
        uint node[nodeCount] <format = hex>;
    }
};

/* Equivelant of SAnimContext::ReadIntoMemory */
struct SAnimContext(byte unkA, byte unkB, uint16 unkC, uint16 unkD, uint16 unkE) {
    uchar unkData1[unkA * 6];
    uchar unkData2[unkC];
    ushort unkData3[unkB];
    uchar unkData4[unkD - (unkB * 8)];
    ushort unkData5[unkA];
    uchar unkData6[unkE - (unkA * 8)];
    SNodeSet nodeSet;
};

/* Equivelant of SAnimContext::Load */
struct SAnimContextLoad {
    uchar unk1;
    uchar unk2;
    ushort unk3;
    ushort unk4;
    ushort unk5;
    SAnimContext animCtx(unk1, unk2, unk3, unk4, unk5);
};

/* Equivelant of SAbsContext::ReadIntoMemory */
struct SAbsContext(byte unkA, uint16 unkB, uint16 unkC, uint16 unkD, uint16 unkE) {
    char unk1[unkA * 6];
    char unk2[unkC];
    if (unkD) {
        char unk3[unkD];        
    }

    if (unkE) {
        char unk4[unkE];
    }

    SNodeSet nodeSet;
    char unk5[unkB * 4];
    uchar unk6;
};

/* Equivelant of SAbsContextLoad::Load */
struct SAbsContextLoad {
    uchar unk1;
    ushort unk2;
    ushort unk3;
    ushort unk4;
    ushort unk5;
    SAbsContext absContext(unk1, unk2, unk3, unk4, unk5);
};

struct CAssetHeader
{
    ushort typeID;
    ushort version;
};

struct NameHashList
{
    uint count;
    uint hash[count] <format = hex>;
    uint stringIDs[count];
};

struct StringList
{
    uint stringTableSize;
    local uint pos <format=hex> = FTell();

    while (true)
    {
        if (FTell() > pos + stringTableSize - 5)
            break;

        CString text;
    }
    FSeek(pos + stringTableSize);
};

struct CPooledNameData
{
    StringList stringList;
    ushort unkCount1;
    ushort hashListCount;
    uint counters1[unkCount1];
    uint nameHashCounts[hashListCount];
    uint unk;
    //List of string hashes + indices
    NameHashList hashList[hashListCount]<optimize=false>;
};


struct CCharInfo
{
    if (!isDKCTF)
    {
        CPooledNameData namePool;
    }
    byte unk1;
    byte unk2; //boolean
    char data[(unk1 & 0x7FFF) * 2];

    if (isDKCTF)
    {
        byte unk3;
        byte unk4;
        byte unk2[12];
        byte flags1;
        uint16 flags2;
    } else {
        SAnimContextLoad animCtxLoadDummy;
        SAbsContextLoad absCtxLoadDummy;
    }

};

struct CAnimationIdMap
{
    uint32 hashnodes;
    uint32 hash[hashnodes];
};

struct CCharacterModelSet
{
    if (ReadByte() == 0)
    {
        CStringFixed name;
    }
    else
    {
        CString name;
    }
    GUID skeletonID;
    CAABox aabox;
};

struct CAnimationInfo
{
    if (ReadByte() == 0)
    {
        CStringFixed name;
    }
    else
    {
        CString name;
    }
    GUID skeletonID;
    FourCC chunkID;
    uint32 unk;
    uint16 unk2[2];
    bool unk3;
    CAABox aabox;
};

struct FCharInf
{
    CAssetHeader assetHeader;
    if (isDKCTF)
    {
        CCharInfo charInfo<optimize=false>;
        if (ReadByte() == 0)
        {
           CStringFixed name;
        }
        else
        {
          CString name;
        }
        GUID skeletonID;
        uint32 modelSets;
        for (charinfoi = 0; charinfoi < modelSets; charinfoi++)
        {
            CCharacterModelSet cms;
        }
        uint32 animInfos;
        for (charinfoi = 0; charinfoi < animInfos; charinfoi++)
        {
            CAnimationInfo cai;
        }
        if (charInfo.flags1 && charInfo.flags2 && 2000)
        {
            CAnimationIdMap caim;
        }
        if (charInfo.flags1 && charInfo.flags2 && 8000)
        {
            //CTransitionInfo cti;
        }
        if (charInfo.flags1 && charInfo.flags2 && 4000)
        {
            //uint32 ctis;
            //CCharacterTransformBits cti[ctis];
        }
        //CAABox endaabox;
    }
    else
    {
        byte count;
        CCharInfo charInfo[count] <optimize=false>;
    }
};


#endif// _CCHARINFO
