#ifndef _CCHARINFO
#define _CCHARINFO

local int charinfoi <hidden=true> = 0;

struct SNodeSet {
    ushort nodeCount;
    ushort nameSet;
    if (nodeCount) {
        uint nodeId[nodeCount] <format = hex>;
    }
};

/* Equivelant of SAnimContext::ReadIntoMemory */
struct SAnimContext(byte unkA, byte unkB, uint16 unkC, uint16 unkD, uint16 unkE) {
    uchar unkData1[unkA * 6];
    uchar unkData2[unkC];
    ushort unkData3[unkB];
    uchar unkData4[unkD - (unkB * 8)];
    ushort unkData5[unkA];
    uchar unkData6[unkE - (unkA * 8)];
    SNodeSet nodeSet;
};

/* Equivelant of SAnimContext::Load */
struct SAnimContextLoad {
    uchar unk1;
    uchar unk2;
    ushort unk3;
    ushort unk4;
    ushort unk5;
    SAnimContext animCtx(unk1, unk2, unk3, unk4, unk5);
};

/* Equivelant of SAbsContext::ReadIntoMemory */
struct SAbsContext(byte unkA, uint16 unkB, uint16 unkC, uint16 unkD, uint16 unkE) {
    char unk1[unkA * 6];
    char unk2[unkC];
    if (unkD) {
        char unk3[unkD];        
    }

    if (unkE) {
        char unk4[unkE];
    }

    SNodeSet nodeSet;
    char unk5[unkB * 4];
    uchar unk6;
};

/* Equivelant of SAbsContextLoad::Load */
struct SAbsContextLoad {
    uchar unk1;
    ushort unk2;
    ushort unk3;
    ushort unk4;
    ushort unk5;
    SAbsContext absContext(unk1, unk2, unk3, unk4, unk5);
};

struct CAssetHeader
{
    ushort typeID;
    ushort version;
};

struct NameHashList
{
    uint count;
    uint hash[count] <format = hex>;
    uint stringIDs[count];
};

struct StringList
{
    uint stringTableSize;
    local uint pos <format=hex> = FTell();

    while (true)
    {
        if (FTell() > pos + stringTableSize - 5)
            break;

        CString text;
    }
    FSeek(pos + stringTableSize);
};

struct CPooledNameData
{
    StringList stringList;
    ushort unkCount1;
    ushort hashListCount;
    uint counters1[unkCount1];
    uint nameHashCounts[hashListCount];
    uint unk;
    //List of string hashes + indices
    NameHashList hashList[hashListCount]<optimize=false>;
};

struct SRenderContext {
    uint16 unk1;
    uint16 unk2;
    uint16 unk3;
    uint16 unk4;
    int32 unk5;
    char unk6[(unk5 + (unk4 + unk1) * 0x32 + unk2 * 2 + unk3 * 2) + 0x30];
};

struct CPooledName {
    ubyte hasName;
    if (hasName) {
        uint nameRef;
    }
};

struct SChannel {
    CPooledName pooledName;
    uint16 unk2;
    ubyte unk3;
    ubyte unk4;
    CGuid guid;
};

/* Equivelant of SChannelLoad::Load */
struct SChannelLoad {
    ubyte channelCount;
    if (channelCount) {
        SChannel channels[channelCount] <optimize = false>;
    }
};


struct SFragDecode {
    uint16 unk1;
    uint16 unk2;
    char data[unk2 * 2];
};

struct SStreamFragDecodeData {
    uint fragDecodeCount;
    if (fragDecodeCount) {
        SFragDecode fragDecodes[fragDecodeCount];
    }
};

struct SConstPool {
    uint16 unk1;
    uint16 unk2;
    uchar data[unk2 * 4];
};


struct SBaseInfo {
    ubyte type;
    ubyte unk1;
    uint16 unk2;
    ubyte unk3;
    ubyte unk4;
    if (unk4) {
        ubyte unk5;
    }
    ubyte unk6;
    if (unk6) {
        ubyte unk7;
    }
    CPooledName pooledName;
};

struct CAnimCompStream {
    uint32 unk1;
    uint16 unk2;
    uint16 unk3;
    uint32 unk4;
    float unk5;
    uint16 unk6;
    uint32 unk7;
    uint16 unk8;
    char data[unk1 - unk2];
};

struct CAnimSequence {
    uint32 unk1;
    uint32 unk2;
    ubyte unk3;
    ubyte unk4;
    struct {
        ubyte unk1;
        ubyte unk2;
        ubyte unk3;
        ushort unk4;
        uint unk5;
    } unk5[unk1];
    if (unk2) {
        char unk6[unk2];
    }
    float unk7;
};

struct CAnimGrid {

};

struct CAnim {
    SBaseInfo baseInfo;
    switch(baseInfo.type) {
    case 0:
        CAnimCompStream anim;
        break;
    case 1:
        CAnimSequence anim;
        break;
    case 2:
        CAnimGrid anim;
        break;
    }
};

struct CCharInfo
{
    if (!isDKCTF)
    {
        CPooledNameData namePool;
    }
    byte unk1;
    byte unk2; //boolean
    char data[unk1 * 2];

    if (isDKCTF)
    {
        byte unk3;
        byte unk4;
        byte unk2[12];
        byte flags1;
        uint16 flags2;
    } else {
        SAnimContextLoad animCtxLoadDummy;
        // local int i;
        // local int id;
        // Printf("=== ANIM CTX ===\n");
        // for (i = 0; i < animCtxLoadDummy.animCtx.nodeSet.nodeCount; ++i) {
        //     id = animCtxLoadDummy.animCtx.nodeSet.nodeId[i];
        //     Printf("%s -> 0x%08X (0x%04X, 0x%04X)  -> %i\n", namePool.stringList.text[namePool.hashList[animCtxLoadDummy.animCtx.nodeSet.nameSet].stringIDs[i]].text, id, (id >> 16) & 0xFFFF, id & 0xFFFF, i);
        // }
        SAbsContextLoad absCtxLoadDummy;
        // Printf("=== ABS CTX ===\n");
        // for (i = 0; i < absCtxLoadDummy.absContext.nodeSet.nodeCount; ++i) {
        //     id = absCtxLoadDummy.absContext.nodeSet.nodeId[i];
        //     Printf("%s -> 0x%08X (0x%04X, 0x%04X) -> %i\n", namePool.stringList.text[namePool.hashList[absCtxLoadDummy.absContext.nodeSet.nameSet].stringIDs[i]].text, id, (id >> 16) & 0xFFFF, id & 0xFFFF, i);
        // }
        SRenderContext renderCtx;
        SChannelLoad channel;
        ubyte unk3;
        ubyte unk4;
        ubyte unk5;
        uint16 unk6;
        uint16 unk7;
        ubyte unk8;

        if (unk8) {
            SStreamFragDecodeData streamFragDecodeData;
        }

        ubyte unk9;
        if (unk9) {
            uint constPoolCount;
            if (constPoolCount) {
                SConstPool constPools[constPoolCount] <optimize = false>;
            }
        }

        uint16 unk10;
        if (unk6 != 0) {

        }

        if (unk6) {
            CAnim anims[unk6] <optimize = false>;
        }
    }

};

struct CAnimationIdMap
{
    uint32 hashnodes;
    uint32 hash[hashnodes];
};

struct CCharacterModelSet
{
    if (ReadByte() == 0)
    {
        CStringFixed name;
    }
    else
    {
        CString name;
    }
    GUID skeletonID;
    CAABox aabox;
};

struct CAnimationInfo
{
    if (ReadByte() == 0)
    {
        CStringFixed name;
    }
    else
    {
        CString name;
    }
    GUID skeletonID;
    FourCC chunkID;
    uint32 unk;
    uint16 unk2[2];
    bool unk3;
    CAABox aabox;
};

struct FCharInf
{
    CAssetHeader assetHeader;
    if (isDKCTF)
    {
        CCharInfo charInfo<optimize=false>;
        if (ReadByte() == 0)
        {
           CStringFixed name;
        }
        else
        {
          CString name;
        }
        GUID skeletonID;
        uint32 modelSets;
        for (charinfoi = 0; charinfoi < modelSets; charinfoi++)
        {
            CCharacterModelSet cms;
        }
        uint32 animInfos;
        for (charinfoi = 0; charinfoi < animInfos; charinfoi++)
        {
            CAnimationInfo cai;
        }
        if (charInfo.flags1 && charInfo.flags2 && 2000)
        {
            CAnimationIdMap caim;
        }
        if (charInfo.flags1 && charInfo.flags2 && 8000)
        {
            //CTransitionInfo cti;
        }
        if (charInfo.flags1 && charInfo.flags2 && 4000)
        {
            //uint32 ctis;
            //CCharacterTransformBits cti[ctis];
        }
        //CAABox endaabox;
    }
    else
    {
        byte count;
        CCharInfo charInfo[count] <optimize=false>;
    }
};


#endif// _CCHARINFO
